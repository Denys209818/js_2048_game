{"mappings":"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","sources":["<anon>","src/scripts/main.js","src/modules/Game.class.js"],"sourcesContent":["\"use strict\";\nvar $a5fd07fa01589658$exports = {};\n\"use strict\";\n/**\n * This class represents the game.\n * Now it has a basic structure, that is needed for testing.\n * Feel free to add more props and methods if needed.\n */ class $a5fd07fa01589658$var$Game {\n    /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */ constructor(initialState){\n        this.tiles = [];\n        this.tempTiles = [];\n        this.removedItems = [];\n        this.changed = 0;\n        this.container = document.getElementById(\"tile-container\");\n        if (initialState) this.convertToTiles(initialState);\n    }\n    moveLeft() {\n        const sorted = this.tiles.sort((item1, item2)=>this.getCoords(item1).x - this.getCoords(item2).x);\n        for (const tile of sorted){\n            const coords = this.getCoords(tile);\n            tile.classList.remove(coords.className);\n            let tempX = 0;\n            while(this.tiles.filter((t)=>t.classList.contains(`tile-cell--${coords.y}--${tempX}`)).length > 0){\n                tempX++;\n                if (tempX > 3) break;\n            }\n            if (tempX > 3) tempX = coords.x;\n            if (tempX <= 3 && parseInt(coords.x) !== tempX) this.changed++;\n            tile.classList.add(`tile-cell--${coords.y}--${tempX}`);\n            if (tempX > 0) {\n                const prevTempCord = tempX - 1;\n                const previousItem = this.tiles.filter((item)=>item.classList.contains(`tile-cell--${coords.y}--${prevTempCord}`))[0];\n                if (previousItem) {\n                    const prevContent = previousItem.querySelector(\".tile-content\");\n                    const currContent = tile.querySelector(\".tile-content\");\n                    if (prevContent.textContent === currContent.textContent && !this.tempTiles.includes(previousItem)) {\n                        tile.classList.remove(`tile-cell--${coords.y}--${tempX}`);\n                        tile.classList.add(`tile-cell--${coords.y}--${prevTempCord}`);\n                        tile.classList.add(\"tile-cell--hide\");\n                        previousItem.classList.remove(`tile-cell--${prevContent.textContent}`);\n                        previousItem.classList.add(`tile-cell--${parseInt(prevContent.textContent) * 2}`);\n                        prevContent.textContent = parseInt(prevContent.textContent) * 2;\n                        this.tempTiles.push(previousItem);\n                        this.removedItems.push(tile);\n                        this.changed++;\n                    }\n                }\n            }\n        }\n    }\n    moveRight() {\n        const sorted = this.tiles.sort((item1, item2)=>this.getCoords(item2).x - this.getCoords(item1).x);\n        for (const tile of sorted){\n            const coords = this.getCoords(tile);\n            tile.classList.remove(coords.className);\n            let tempX = 3;\n            while(this.tiles.filter((t)=>t.classList.contains(`tile-cell--${coords.y}--${tempX}`)).length > 0){\n                tempX--;\n                if (tempX < 0) break;\n            }\n            if (tempX < 0) tempX = coords.x;\n            if (tempX >= 0 && parseInt(coords.x) !== tempX) this.changed++;\n            tile.classList.add(`tile-cell--${coords.y}--${tempX}`);\n            if (tempX < 3) {\n                const prevTempCord = tempX + 1;\n                const previousItem = this.tiles.filter((item)=>item.classList.contains(`tile-cell--${coords.y}--${prevTempCord}`))[0];\n                if (previousItem) {\n                    const prevContent = previousItem.querySelector(\".tile-content\");\n                    const currContent = tile.querySelector(\".tile-content\");\n                    if (prevContent.textContent === currContent.textContent && !this.tempTiles.includes(previousItem)) {\n                        tile.classList.remove(`tile-cell--${coords.y}--${tempX}`);\n                        tile.classList.add(`tile-cell--${coords.y}--${prevTempCord}`);\n                        tile.classList.add(\"tile-cell--hide\");\n                        previousItem.classList.remove(`tile-cell--${prevContent.textContent}`);\n                        previousItem.classList.add(`tile-cell--${parseInt(prevContent.textContent) * 2}`);\n                        prevContent.textContent = parseInt(prevContent.textContent) * 2;\n                        this.tempTiles.push(previousItem);\n                        this.removedItems.push(tile);\n                        this.changed++;\n                    }\n                }\n            }\n        }\n    }\n    moveUp() {\n        const sorted = this.tiles.sort((item1, item2)=>this.getCoords(item1).y - this.getCoords(item2).y);\n        for (const tile of sorted){\n            const coords = this.getCoords(tile);\n            tile.classList.remove(coords.className);\n            let tempY = 0;\n            while(this.tiles.filter((t)=>t.classList.contains(`tile-cell--${tempY}--${coords.x}`)).length > 0){\n                tempY++;\n                if (tempY > 3) break;\n            }\n            if (tempY > 3) tempY = coords.y;\n            if (tempY <= 3 && parseInt(coords.y) !== tempY) this.changed++;\n            tile.classList.add(`tile-cell--${tempY}--${coords.x}`);\n            if (tempY > 0) {\n                const prevTempCord = tempY - 1;\n                const previousItem = this.tiles.filter((item)=>item.classList.contains(`tile-cell--${prevTempCord}--${coords.x}`))[0];\n                if (previousItem) {\n                    const prevContent = previousItem.querySelector(\".tile-content\");\n                    const currContent = tile.querySelector(\".tile-content\");\n                    if (prevContent.textContent === currContent.textContent && !this.tempTiles.includes(previousItem)) {\n                        tile.classList.remove(`tile-cell--${tempY}--${coords.x}`);\n                        tile.classList.add(`tile-cell--${prevTempCord}--${coords.x}`);\n                        tile.classList.add(\"tile-cell--hide\");\n                        previousItem.classList.remove(`tile-cell--${prevContent.textContent}`);\n                        previousItem.classList.add(`tile-cell--${parseInt(prevContent.textContent) * 2}`);\n                        prevContent.textContent = parseInt(prevContent.textContent) * 2;\n                        this.tempTiles.push(previousItem);\n                        this.removedItems.push(tile);\n                        this.changed++;\n                    }\n                }\n            }\n        }\n    }\n    moveDown() {\n        const sorted = this.tiles.sort((item1, item2)=>this.getCoords(item2).y - this.getCoords(item1).y);\n        for (const tile of sorted){\n            const coords = this.getCoords(tile);\n            tile.classList.remove(coords.className);\n            let tempY = 3;\n            while(this.tiles.filter((t)=>t.classList.contains(`tile-cell--${tempY}--${coords.x}`)).length > 0){\n                tempY--;\n                if (tempY < 0) break;\n            }\n            if (tempY < 0) tempY = coords.y;\n            if (tempY >= 0 && parseInt(coords.y) !== tempY) this.changed++;\n            tile.classList.add(`tile-cell--${tempY}--${coords.x}`);\n            if (tempY < 3) {\n                const prevTempCord = tempY + 1;\n                const previousItem = this.tiles.filter((item)=>item.classList.contains(`tile-cell--${prevTempCord}--${coords.x}`))[0];\n                if (previousItem) {\n                    const prevContent = previousItem.querySelector(\".tile-content\");\n                    const currContent = tile.querySelector(\".tile-content\");\n                    if (prevContent.textContent === currContent.textContent && !this.tempTiles.includes(previousItem)) {\n                        tile.classList.remove(`tile-cell--${tempY}--${coords.x}`);\n                        tile.classList.add(`tile-cell--${prevTempCord}--${coords.x}`);\n                        tile.classList.add(\"tile-cell--hide\");\n                        previousItem.classList.remove(`tile-cell--${prevContent.textContent}`);\n                        previousItem.classList.add(`tile-cell--${parseInt(prevContent.textContent) * 2}`);\n                        prevContent.textContent = parseInt(prevContent.textContent) * 2;\n                        this.tempTiles.push(previousItem);\n                        this.removedItems.push(tile);\n                        this.changed++;\n                    }\n                }\n            }\n        }\n    }\n    /**\n   * @returns {number}\n   */ getScore() {\n        const state = this.getState();\n        let sum = 0;\n        for(let i = 0; i < 4; i++)for(let j = 0; j < 4; j++)sum += state[i][j];\n        return sum;\n    }\n    /**\n   * @returns {number[][]}\n   */ getState() {\n        const result = [];\n        for(let i = 0; i < 4; i++)result.push([\n            0,\n            0,\n            0,\n            0\n        ]);\n        for (const tile of this.tiles.filter((t)=>!t.classList.contains(\"tile-cell--hide\"))){\n            const coords = this.getCoords(tile);\n            result[coords.y][coords.x] = parseInt(tile.querySelector(\".tile-content\").innerHTML);\n        }\n        return result;\n    }\n    /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */ getStatus() {\n        if (this.tiles.filter((tile)=>{\n            const inner = tile.querySelector(\".tile-content\");\n            return parseInt(inner.innerHTML) === 2048;\n        }).length > 0) return \"win\";\n        if (!this.checkPosibilityToContinue()) return \"lose\";\n        else {\n            const btn = document.getElementsByClassName(\"button\")[0].classList.contains(\"start\");\n            if (btn) return \"idle\";\n            else return \"playing\";\n        }\n    }\n    /**\n   * Starts the game.\n   */ start() {\n        const btn = document.getElementsByClassName(\"button\")[0];\n        this.tiles = [];\n        btn.addEventListener(\"click\", this.connectStart.bind(this));\n        document.addEventListener(\"keydown\", this.press.bind(this));\n    }\n    /**\n   * Resets the game.\n   */ restart() {\n        this.start();\n    }\n    // Add your own methods here\n    connectStart(e) {\n        e.preventDefault();\n        const btn = e.target;\n        this.tiles = [];\n        document.getElementById(\"tile-container\").innerHTML = \"\";\n        if (btn.classList.contains(\"start\")) {\n            btn.classList.remove(\"start\");\n            btn.classList.add(\"restart\");\n            btn.textContent = \"Restart\";\n        }\n        this.spawnItem();\n        this.spawnItem();\n        const visible = [\n            ...document.getElementsByClassName(\"message\")\n        ].filter((x)=>!x.classList.contains(\"hidden\"))[0];\n        if (visible) visible.classList.add(\"hidden\");\n        document.getElementsByClassName(\"message-start\")[0].classList.remove(\"hidden\");\n    }\n    press(e) {\n        const key = e.key;\n        this.tempTiles = [];\n        this.removedItems = [];\n        this.changed = 0;\n        if (this.tiles.length === 0) return;\n        switch(key){\n            case \"ArrowUp\":\n                this.moveUp();\n                break;\n            case \"ArrowDown\":\n                this.moveDown();\n                break;\n            case \"ArrowLeft\":\n                this.moveLeft();\n                break;\n            case \"ArrowRight\":\n                this.moveRight();\n                break;\n        }\n        this.sleep().then(()=>{\n            for(let i = 0; i < this.removedItems.length; i++)this.removedItems[i].remove();\n            if (this.changed > 0) this.spawnItem();\n            if (!this.checkPosibilityToContinue()) {\n                document.addEventListener(\"keydown\", ()=>{});\n                const getStat = this.getStatus();\n                document.getElementsByClassName(\"message-start\")[0].classList.add(\"hidden\");\n                document.getElementsByClassName(`message-${getStat}`)[0].classList.remove(\"hidden\");\n            }\n        });\n    }\n    setScoreHTML() {\n        const score = document.getElementsByClassName(\"game-score\")[0];\n        score.textContent = this.getScore();\n    }\n    spawnItem() {\n        const activeTiles = this.tiles.filter((t)=>!t.classList.contains(\"tile-cell--hide\"));\n        if (activeTiles.length < 16) {\n            const newItem = document.createElement(\"div\");\n            const side = Math.round(Math.random() * 10) < 2 ? 4 : 2;\n            let tempX = Math.floor(Math.random() * 4);\n            let tempY = Math.floor(Math.random() * 4);\n            while(activeTiles.filter((t)=>t.classList.contains(`tile-cell--${tempY}--${tempX}`)).length > 0){\n                tempX = Math.floor(Math.random() * 4);\n                tempY = Math.floor(Math.random() * 4);\n            }\n            newItem.classList.add(\"tile-cell\");\n            newItem.classList.add(`tile-cell--${side}`);\n            newItem.classList.add(`tile-cell--${tempY}--${tempX}`);\n            newItem.classList.add(\"tile-cell--hide\");\n            const pItem = document.createElement(\"p\");\n            pItem.classList.add(\"tile-content\");\n            pItem.textContent = side;\n            newItem.appendChild(pItem);\n            this.container.append(newItem);\n            this.tiles.push(newItem);\n            newItem.classList.remove(\"tile-cell--hide\");\n            this.setScoreHTML();\n        }\n    }\n    sleep(ms = 200) {\n        const prom = new Promise((resolve)=>{\n            setTimeout(()=>{\n                resolve();\n            }, ms);\n        });\n        return prom;\n    }\n    getCoords(tile) {\n        let x = 0;\n        let y = 0;\n        let classN = \"\";\n        for (const className of tile.classList)if (className.length >= 15 && className !== \"tile-cell--hide\") {\n            x = className.slice(-1);\n            y = className.slice(-4, -3);\n            classN = className;\n        }\n        return {\n            x: x,\n            y: y,\n            className: classN\n        };\n    }\n    checkPosibilityToContinue() {\n        this.tiles = this.tiles.filter((cell)=>!cell.classList.contains(\"tile-cell--hide\"));\n        if (this.tiles.length >= 16) {\n            for(let i = 0; i < this.tiles.length; i++){\n                const current = this.tiles[i].querySelector(\".tile-content\");\n                const cCoords = this.getCoords(this.tiles[i]);\n                if (cCoords.x > 0) {\n                    const prevLeft = this.tiles.filter((cell)=>cell.classList.contains(`tile-cell--${cCoords.y}--${cCoords.x - 1}`))[0];\n                    if (prevLeft && current.textContent === prevLeft.querySelector(\".tile-content\").textContent) return true;\n                }\n                if (cCoords.y > 0) {\n                    const prevTop = this.tiles.filter((cell)=>cell.classList.contains(`tile-cell--${cCoords.y - 1}--${cCoords.x}`))[0];\n                    if (prevTop && current.textContent === prevTop.querySelector(\".tile-content\").textContent) return true;\n                }\n                if (cCoords.y < 3) {\n                    const prevBottom = this.tiles.filter((cell)=>cell.classList.contains(`tile-cell--${cCoords.y + 1}--${cCoords.x}`))[0];\n                    if (prevBottom && current.textContent === prevBottom.querySelector(\".tile-content\").textContent) return true;\n                }\n                if (cCoords.x < 3) {\n                    const prevRight = this.tiles.filter((cell)=>cell.classList.contains(`tile-cell--${cCoords.y}--${cCoords.x + 1}`))[0];\n                    if (prevRight && current.textContent === prevRight.querySelector(\".tile-content\").textContent) return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n    convertToTiles(state) {\n        document.getElementById(\"tile-container\").innerHTML = \"\";\n        for(let i = 0; i < 4; i++){\n            for(let j = 0; j < 4; j++)if (state[i][j] > 0) {\n                const div = document.createElement(\"div\");\n                div.classList.add(\"tile-cell\");\n                div.classList.add(`tile-cell--${state[i][j]}`);\n                div.classList.add(`tile-cell--${i}--${j}`);\n                const p = document.createElement(\"p\");\n                p.classList.add(\"tile-content\");\n                p.textContent = state[i][j];\n                div.appendChild(p);\n                document.getElementById(\"tile-container\").appendChild(div);\n                this.tiles.add(div);\n            }\n        }\n    }\n}\n$a5fd07fa01589658$exports = $a5fd07fa01589658$var$Game;\n\n\nconst $09e991522ca7e64e$var$game = new $a5fd07fa01589658$exports();\n$09e991522ca7e64e$var$game.start();\n\n\n//# sourceMappingURL=index.a8eaab70.js.map\n","'use strict';\n\n// Uncomment the next lines to use your game instance in the browser\nconst Game = require('../modules/Game.class');\nconst game = new Game();\n\ngame.start();\n","'use strict';\n\n/**\n * This class represents the game.\n * Now it has a basic structure, that is needed for testing.\n * Feel free to add more props and methods if needed.\n */\nclass Game {\n  /**\n   * Creates a new game instance.\n   *\n   * @param {number[][]} initialState\n   * The initial state of the board.\n   * @default\n   * [[0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0],\n   *  [0, 0, 0, 0]]\n   *\n   * If passed, the board will be initialized with the provided\n   * initial state.\n   */\n  constructor(initialState) {\n    this.tiles = [];\n    this.tempTiles = [];\n    this.removedItems = [];\n    this.changed = 0;\n    this.container = document.getElementById('tile-container');\n\n    if (initialState) {\n      this.convertToTiles(initialState);\n    }\n  }\n\n  moveLeft() {\n    const sorted = this.tiles.sort((item1, item2) =>\n      this.getCoords(item1).x - this.getCoords(item2).x);\n\n    for (const tile of sorted) {\n      const coords = this.getCoords(tile);\n\n      tile.classList.remove(coords.className);\n\n      let tempX = 0;\n\n      while (this.tiles\n        .filter(t => t.classList\n          .contains(`tile-cell--${coords.y}--${tempX}`))\n        .length > 0) {\n        tempX++;\n\n        if (tempX > 3) {\n          break;\n        }\n      }\n\n      if (tempX > 3) {\n        tempX = coords.x;\n      }\n\n      if (tempX <= 3 && parseInt(coords.x) !== tempX) {\n        this.changed++;\n      }\n\n      tile.classList.add(`tile-cell--${coords.y}--${tempX}`);\n\n      if (tempX > 0) {\n        const prevTempCord = tempX - 1;\n\n        const previousItem = this.tiles\n          .filter(item => item.classList\n            .contains(`tile-cell--${coords.y}--${prevTempCord}`))[0];\n\n        if (previousItem) {\n          const prevContent = previousItem.querySelector('.tile-content');\n          const currContent = tile.querySelector('.tile-content');\n\n          if (prevContent.textContent === currContent.textContent\n            && !this.tempTiles.includes(previousItem)) {\n            tile.classList.remove(`tile-cell--${coords.y}--${tempX}`);\n            tile.classList.add(`tile-cell--${coords.y}--${prevTempCord}`);\n            tile.classList.add('tile-cell--hide');\n\n            previousItem.classList\n              .remove(`tile-cell--${prevContent.textContent}`);\n\n            previousItem.classList\n              .add(`tile-cell--${parseInt(prevContent.textContent) * 2}`);\n\n            prevContent.textContent = parseInt(prevContent.textContent) * 2;\n\n            this.tempTiles.push(previousItem);\n            this.removedItems.push(tile);\n\n            this.changed++;\n          }\n        }\n      }\n    }\n  }\n\n  moveRight() {\n    const sorted = this.tiles.sort((item1, item2) =>\n      this.getCoords(item2).x - this.getCoords(item1).x);\n\n    for (const tile of sorted) {\n      const coords = this.getCoords(tile);\n\n      tile.classList.remove(coords.className);\n\n      let tempX = 3;\n\n      while (this.tiles\n        .filter(t => t.classList\n          .contains(`tile-cell--${coords.y}--${tempX}`))\n        .length > 0) {\n        tempX--;\n\n        if (tempX < 0) {\n          break;\n        }\n      }\n\n      if (tempX < 0) {\n        tempX = coords.x;\n      }\n\n      if (tempX >= 0 && parseInt(coords.x) !== tempX) {\n        this.changed++;\n      }\n\n      tile.classList.add(`tile-cell--${coords.y}--${tempX}`);\n\n      if (tempX < 3) {\n        const prevTempCord = tempX + 1;\n\n        const previousItem = this.tiles\n          .filter(item => item.classList\n            .contains(`tile-cell--${coords.y}--${prevTempCord}`))[0];\n\n        if (previousItem) {\n          const prevContent = previousItem.querySelector('.tile-content');\n          const currContent = tile.querySelector('.tile-content');\n\n          if (prevContent.textContent === currContent.textContent\n            && !this.tempTiles.includes(previousItem)) {\n            tile.classList.remove(`tile-cell--${coords.y}--${tempX}`);\n            tile.classList.add(`tile-cell--${coords.y}--${prevTempCord}`);\n            tile.classList.add('tile-cell--hide');\n\n            previousItem.classList\n              .remove(`tile-cell--${prevContent.textContent}`);\n\n            previousItem.classList\n              .add(`tile-cell--${parseInt(prevContent.textContent) * 2}`);\n\n            prevContent.textContent = parseInt(prevContent.textContent) * 2;\n\n            this.tempTiles.push(previousItem);\n            this.removedItems.push(tile);\n\n            this.changed++;\n          }\n        }\n      }\n    }\n  }\n\n  moveUp() {\n    const sorted = this.tiles.sort((item1, item2) =>\n      this.getCoords(item1).y - this.getCoords(item2).y);\n\n    for (const tile of sorted) {\n      const coords = this.getCoords(tile);\n\n      tile.classList.remove(coords.className);\n\n      let tempY = 0;\n\n      while (this.tiles\n        .filter(t => t.classList\n          .contains(`tile-cell--${tempY}--${coords.x}`))\n        .length > 0) {\n        tempY++;\n\n        if (tempY > 3) {\n          break;\n        }\n      }\n\n      if (tempY > 3) {\n        tempY = coords.y;\n      }\n\n      if (tempY <= 3 && parseInt(coords.y) !== tempY) {\n        this.changed++;\n      }\n\n      tile.classList.add(`tile-cell--${tempY}--${coords.x}`);\n\n      if (tempY > 0) {\n        const prevTempCord = tempY - 1;\n\n        const previousItem = this.tiles\n          .filter(item => item.classList\n            .contains(`tile-cell--${prevTempCord}--${coords.x}`))[0];\n\n        if (previousItem) {\n          const prevContent = previousItem.querySelector('.tile-content');\n          const currContent = tile.querySelector('.tile-content');\n\n          if (prevContent.textContent === currContent.textContent\n            && !this.tempTiles.includes(previousItem)) {\n            tile.classList.remove(`tile-cell--${tempY}--${coords.x}`);\n            tile.classList.add(`tile-cell--${prevTempCord}--${coords.x}`);\n            tile.classList.add('tile-cell--hide');\n\n            previousItem.classList\n              .remove(`tile-cell--${prevContent.textContent}`);\n\n            previousItem.classList\n              .add(`tile-cell--${parseInt(prevContent.textContent) * 2}`);\n\n            prevContent.textContent = parseInt(prevContent.textContent) * 2;\n\n            this.tempTiles.push(previousItem);\n            this.removedItems.push(tile);\n\n            this.changed++;\n          }\n        }\n      }\n    }\n  }\n\n  moveDown() {\n    const sorted = this.tiles.sort((item1, item2) =>\n      this.getCoords(item2).y - this.getCoords(item1).y);\n\n    for (const tile of sorted) {\n      const coords = this.getCoords(tile);\n\n      tile.classList.remove(coords.className);\n\n      let tempY = 3;\n\n      while (this.tiles\n        .filter(t => t.classList\n          .contains(`tile-cell--${tempY}--${coords.x}`))\n        .length > 0) {\n        tempY--;\n\n        if (tempY < 0) {\n          break;\n        }\n      }\n\n      if (tempY < 0) {\n        tempY = coords.y;\n      }\n\n      if (tempY >= 0 && parseInt(coords.y) !== tempY) {\n        this.changed++;\n      }\n\n      tile.classList.add(`tile-cell--${tempY}--${coords.x}`);\n\n      if (tempY < 3) {\n        const prevTempCord = tempY + 1;\n\n        const previousItem = this.tiles\n          .filter(item => item.classList\n            .contains(`tile-cell--${prevTempCord}--${coords.x}`))[0];\n\n        if (previousItem) {\n          const prevContent = previousItem.querySelector('.tile-content');\n          const currContent = tile.querySelector('.tile-content');\n\n          if (prevContent.textContent === currContent.textContent\n            && !this.tempTiles.includes(previousItem)) {\n            tile.classList.remove(`tile-cell--${tempY}--${coords.x}`);\n            tile.classList.add(`tile-cell--${prevTempCord}--${coords.x}`);\n            tile.classList.add('tile-cell--hide');\n\n            previousItem.classList\n              .remove(`tile-cell--${prevContent.textContent}`);\n\n            previousItem.classList\n              .add(`tile-cell--${parseInt(prevContent.textContent) * 2}`);\n\n            prevContent.textContent = parseInt(prevContent.textContent) * 2;\n\n            this.tempTiles.push(previousItem);\n            this.removedItems.push(tile);\n\n            this.changed++;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @returns {number}\n   */\n  getScore() {\n    const state = this.getState();\n    let sum = 0;\n\n    for (let i = 0; i < 4; i++) {\n      for (let j = 0; j < 4; j++) {\n        sum += state[i][j];\n      }\n    }\n\n    return sum;\n  }\n\n  /**\n   * @returns {number[][]}\n   */\n  getState() {\n    const result = [];\n\n    for (let i = 0; i < 4; i++) {\n      result.push([0, 0, 0, 0]);\n    }\n\n    for (const tile of this.tiles\n      .filter(t => !t.classList.contains('tile-cell--hide'))) {\n      const coords = this.getCoords(tile);\n\n      result[coords.y][coords.x] = parseInt(tile\n        .querySelector('.tile-content').innerHTML);\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns the current game status.\n   *\n   * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n   *\n   * `idle` - the game has not started yet (the initial state);\n   * `playing` - the game is in progress;\n   * `win` - the game is won;\n   * `lose` - the game is lost\n   */\n  getStatus() {\n    if (this.tiles.filter(tile => {\n      const inner = tile.querySelector('.tile-content');\n\n      return parseInt(inner.innerHTML) === 2048;\n    }).length > 0) {\n      return 'win';\n    }\n\n    if (!this.checkPosibilityToContinue()) {\n      return 'lose';\n    } else {\n      const btn = document\n        .getElementsByClassName('button')[0].classList.contains('start');\n\n      if (btn) {\n        return 'idle';\n      } else {\n        return 'playing';\n      }\n    }\n  }\n\n  /**\n   * Starts the game.\n   */\n  start() {\n    const btn = document.getElementsByClassName('button')[0];\n\n    this.tiles = [];\n\n    btn.addEventListener('click', this.connectStart.bind(this));\n    document.addEventListener('keydown', this.press.bind(this));\n  }\n\n  /**\n   * Resets the game.\n   */\n  restart() {\n    this.start();\n  }\n\n  // Add your own methods here\n\n  connectStart(e) {\n    e.preventDefault();\n\n    const btn = e.target;\n\n    this.tiles = [];\n    document.getElementById('tile-container').innerHTML = '';\n\n    if (btn.classList.contains('start')) {\n      btn.classList.remove('start');\n      btn.classList.add('restart');\n\n      btn.textContent = 'Restart';\n    }\n\n    this.spawnItem();\n    this.spawnItem();\n\n    const visible = [...document.getElementsByClassName('message')]\n      .filter(x => !x.classList.contains('hidden'))[0];\n\n    if (visible) {\n      visible.classList.add('hidden');\n    }\n\n    document\n      .getElementsByClassName('message-start')[0]\n      .classList.remove('hidden');\n  }\n\n  press(e) {\n    const key = e.key;\n\n    this.tempTiles = [];\n    this.removedItems = [];\n    this.changed = 0;\n\n    if (this.tiles.length === 0) {\n      return;\n    }\n\n    switch (key) {\n      case 'ArrowUp': {\n        this.moveUp();\n\n        break;\n      }\n\n      case 'ArrowDown': {\n        this.moveDown();\n\n        break;\n      }\n\n      case 'ArrowLeft': {\n        this.moveLeft();\n\n        break;\n      }\n\n      case 'ArrowRight': {\n        this.moveRight();\n\n        break;\n      }\n    }\n\n    this.sleep().then(() => {\n      for (let i = 0; i < this.removedItems.length; i++) {\n        this.removedItems[i].remove();\n      }\n\n      if (this.changed > 0) {\n        this.spawnItem();\n      }\n\n      if (!this.checkPosibilityToContinue()) {\n        document.addEventListener('keydown', () => {});\n\n        const getStat = this.getStatus();\n\n        document\n          .getElementsByClassName('message-start')[0]\n          .classList.add('hidden');\n\n        document\n          .getElementsByClassName(`message-${getStat}`)[0]\n          .classList.remove('hidden');\n      }\n    });\n  }\n\n  setScoreHTML() {\n    const score = document.getElementsByClassName('game-score')[0];\n\n    score.textContent = this.getScore();\n  }\n\n  spawnItem() {\n    const activeTiles = this.tiles\n      .filter(t => !t.classList.contains('tile-cell--hide'));\n\n    if (activeTiles\n      .length < 16) {\n      const newItem = document.createElement('div');\n\n      const side = Math.round(Math.random() * 10) < 2 ? 4 : 2;\n\n      let tempX = Math.floor(Math.random() * 4);\n      let tempY = Math.floor(Math.random() * 4);\n\n      while (activeTiles\n        .filter(t => t.classList\n          .contains(`tile-cell--${tempY}--${tempX}`)).length > 0) {\n        tempX = Math.floor(Math.random() * 4);\n        tempY = Math.floor(Math.random() * 4);\n      }\n\n      newItem.classList.add('tile-cell');\n      newItem.classList.add(`tile-cell--${side}`);\n      newItem.classList.add(`tile-cell--${tempY}--${tempX}`);\n      newItem.classList.add('tile-cell--hide');\n\n      const pItem = document.createElement('p');\n\n      pItem.classList.add('tile-content');\n      pItem.textContent = side;\n\n      newItem.appendChild(pItem);\n      this.container.append(newItem);\n      this.tiles.push(newItem);\n\n      newItem.classList.remove('tile-cell--hide');\n\n      this.setScoreHTML();\n    }\n  }\n\n  sleep(ms = 200) {\n    const prom = new Promise((resolve) => {\n      setTimeout(() => {\n        resolve();\n      }, ms);\n    });\n\n    return prom;\n  }\n\n  getCoords(tile) {\n    let x = 0;\n    let y = 0;\n    let classN = '';\n\n    for (const className of tile.classList) {\n      if (className.length >= 15 && className !== 'tile-cell--hide') {\n        x = className.slice(-1);\n        y = className.slice(-4, -3);\n\n        classN = className;\n      }\n    }\n\n    return {\n      x,\n      y,\n      className: classN,\n    };\n  }\n\n  checkPosibilityToContinue() {\n    this.tiles = this.tiles\n      .filter(cell => !cell.classList.contains('tile-cell--hide'));\n\n    if (this.tiles.length >= 16) {\n      for (let i = 0; i < this.tiles.length; i++) {\n        const current = this.tiles[i].querySelector('.tile-content');\n        const cCoords = this.getCoords(this.tiles[i]);\n\n        if (cCoords.x > 0) {\n          const prevLeft = this.tiles\n            .filter(cell => cell.classList\n              .contains(`tile-cell--${cCoords.y}--${cCoords.x - 1}`))[0];\n\n          if (prevLeft && current.textContent === prevLeft\n            .querySelector('.tile-content').textContent) {\n            return true;\n          }\n        }\n\n        if (cCoords.y > 0) {\n          const prevTop = this.tiles\n            .filter(cell => cell.classList\n              .contains(`tile-cell--${cCoords.y - 1}--${cCoords.x}`))[0];\n\n          if (prevTop && current.textContent === prevTop\n            .querySelector('.tile-content').textContent) {\n            return true;\n          }\n        }\n\n        if (cCoords.y < 3) {\n          const prevBottom = this.tiles\n            .filter(cell => cell.classList\n              .contains(`tile-cell--${cCoords.y + 1}--${cCoords.x}`))[0];\n\n          if (prevBottom && current.textContent === prevBottom\n            .querySelector('.tile-content').textContent) {\n            return true;\n          }\n        }\n\n        if (cCoords.x < 3) {\n          const prevRight = this.tiles\n            .filter(cell => cell.classList\n              .contains(`tile-cell--${cCoords.y}--${cCoords.x + 1}`))[0];\n\n          if (prevRight && current.textContent === prevRight\n            .querySelector('.tile-content').textContent) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  convertToTiles(state) {\n    document.getElementById('tile-container').innerHTML = '';\n\n    for (let i = 0; i < 4; i++) {\n      for (let j = 0; j < 4; j++) {\n        if (state[i][j] > 0) {\n          const div = document.createElement('div');\n\n          div.classList.add('tile-cell');\n          div.classList.add(`tile-cell--${state[i][j]}`);\n          div.classList.add(`tile-cell--${i}--${j}`);\n\n          const p = document.createElement('p');\n\n          p.classList.add('tile-content');\n          p.textContent = state[i][j];\n\n          div.appendChild(p);\n\n          document.getElementById('tile-container')\n            .appendChild(div);\n\n          this.tiles.add(div);\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = Game;\n"],"names":["constructor","initialState","tiles","tempTiles","removedItems","changed","container","document","getElementById","convertToTiles","moveLeft","tile","sort","item1","item2","getCoords","x","coords","classList","remove","className","tempX","filter","t","contains","y","length","parseInt","add","prevTempCord","previousItem","item","prevContent","querySelector","currContent","textContent","includes","push","moveRight","moveUp","tempY","moveDown","getScore","state","getState","sum","i","j","result","innerHTML","getStatus","inner","checkPosibilityToContinue","getElementsByClassName","start","btn","addEventListener","connectStart","bind","press","restart","e","preventDefault","target","spawnItem","visible","key","sleep","then","getStat","setScoreHTML","score","activeTiles","newItem","createElement","side","Math","round","random","floor","pItem","appendChild","append","ms","Promise","resolve","setTimeout","classN","slice","cell","current","cCoords","prevLeft","prevTop","prevBottom","prevRight","div","p"],"version":3,"file":"index.a8eaab70.js.map"}